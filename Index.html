<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<title>Dodger — iOS Friendly</title>
<style>
  :root {
    --bg:#0c0f14;
    --fg:#e9efff;
    --accent:#58a6ff;
    --danger:#ff6b6b;
    --muted:#6b7280;
  }
  * { box-sizing: border-box; }
  html, body {
    margin:0; padding:0; height:100%; width:100%;
    background:var(--bg); color:var(--fg);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    -webkit-font-smoothing: antialiased;
    -webkit-tap-highlight-color: transparent;
  }
  body {
    overflow:hidden;
    touch-action:none;              /* prevent scroll/zoom gestures over canvas */
    -webkit-user-select:none; user-select:none;
    -webkit-touch-callout:none;
  }
  #wrap {
    position:fixed; inset:0; display:flex; flex-direction:column;
  }
  header {
    position:absolute; top:0; left:0; right:0; z-index:5;
    display:flex; align-items:center; justify-content:space-between;
    padding:10px 12px; gap:8px; pointer-events:none;
  }
  header .hud {
    display:flex; gap:10px; align-items:center; pointer-events:auto;
    background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.08);
    padding:6px 10px; border-radius:12px; backdrop-filter: blur(8px);
  }
  header .hud span { font-variant-numeric: tabular-nums; }
  header .btn {
    pointer-events:auto; border:none; border-radius:12px; padding:8px 12px;
    background:rgba(255,255,255,0.08); color:var(--fg); font-weight:600;
  }
  header .btn:active { transform:scale(0.98); }
  canvas { display:block; width:100%; height:100%; }
  /* On-screen controls */
  .controls {
    position:absolute; left:0; right:0; bottom:0; z-index:6;
    display:flex; justify-content:space-between; gap:12px; padding:14px;
    pointer-events:none; /* children enable their own */
  }
  .pad {
    flex:1; min-height:92px; border-radius:16px;
    background:linear-gradient(180deg, rgba(255,255,255,0.07), rgba(255,255,255,0.03));
    border:1px solid rgba(255,255,255,0.1);
    display:flex; align-items:center; justify-content:center;
    pointer-events:auto;
    -webkit-user-select:none;
  }
  .pad:active { outline:2px solid rgba(88,166,255,0.8); }
  .pad span {
    font-size:28px; line-height:1; opacity:0.9; filter: drop-shadow(0 2px 0 rgba(0,0,0,0.35));
  }
  .right { }
  .left  { }
  /* Overlay */
  .overlay {
    position:absolute; inset:0; z-index:7; display:flex; align-items:center; justify-content:center;
    background: radial-gradient(1200px 800px at 50% 40%, rgba(88,166,255,0.12), rgba(12,15,20,0.92) 60%);
    text-align:center; padding:24px;
  }
  .card {
    max-width:520px; width:92%;
    background:rgba(255,255,255,0.08);
    border:1px solid rgba(255,255,255,0.14);
    border-radius:18px; padding:18px 18px 14px; margin:0 auto;
    backdrop-filter: blur(10px);
  }
  .title { font-size:28px; font-weight:800; letter-spacing:0.3px; margin-bottom:8px; }
  .subtitle { color:var(--muted); margin-bottom:16px; }
  .row { display:flex; gap:10px; justify-content:center; flex-wrap:wrap; }
  .pill {
    background:rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.12);
    border-radius:999px; padding:8px 12px; font-weight:600;
  }
  .go {
    margin-top:14px;
    width:100%; padding:12px 14px; font-weight:800; font-size:18px;
    border-radius:14px; border:none; color:#0b1220; background:var(--accent);
  }
  .go:active { transform: translateY(1px); }
  .muted { color:var(--muted); font-size:13px; margin-top:10px; }
  .danger { color: var(--danger); }
  .tiny { font-size:11px; opacity:0.8; margin-top:6px; }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" aria-label="Dodger game area"></canvas>

  <header>
    <div class="hud"><strong>Score:</strong><span id="score">0</span></div>
    <div class="hud"><strong>Best:</strong><span id="best">0</span></div>
    <button id="pauseBtn" class="btn" aria-label="Pause or resume">Pause</button>
  </header>

  <div class="controls" aria-hidden="false">
    <div class="pad left"  id="leftPad"  role="button" aria-label="Move left"><span>⟵</span></div>
    <div class="pad right" id="rightPad" role="button" aria-label="Move right"><span>⟶</span></div>
  </div>

  <div class="overlay" id="overlay">
    <div class="card">
      <div class="title">DODGER</div>
      <div class="subtitle">Drag or tap the left/right pads to avoid falling blocks. Survive to score.</div>
      <div class="row">
        <div class="pill">Tap / Hold ◀ ▶</div>
        <div class="pill">Swipe anywhere</div>
        <div class="pill">Pause: top-right</div>
      </div>
      <button class="go" id="startBtn">Start</button>
      <div class="muted">Tip: Add to Home Screen for full-screen play on iPhone.</div>
      <div class="tiny">No ads. No tracking. Your high score is stored on-device.</div>
    </div>
  </div>
</div>

<script>
(function () {
  "use strict";

  // --- Canvas setup with DPR scaling for crisp rendering on Retina/iOS ---
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d", { alpha: false, desynchronized: true });

  let width = 0, height = 0, dpr = Math.max(1, window.devicePixelRatio || 1);

  function fit() {
    // Use innerWidth/innerHeight to avoid iOS 100vh issues.
    width  = Math.max(320, Math.floor(window.innerWidth  || document.documentElement.clientWidth));
    height = Math.max(480, Math.floor(window.innerHeight || document.documentElement.clientHeight));
    dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width  = Math.floor(width * dpr);
    canvas.height = Math.floor(height * dpr);
    canvas.style.width = width + "px";
    canvas.style.height = height + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  fit();
  window.addEventListener("resize", fit);

  // --- Game state ---
  const state = {
    running:false, paused:false, over:false,
    score:0, best: Number(localStorage.getItem("dodger_best") || 0),
    time:0, last: performance.now(),
    player:{ x:0, y:0, w:44, h:44, speed:420, vx:0 },
    blocks:[], blockTimer:0,
    difficulty:1,
    input:{ left:false, right:false, swipeVX:0 }
  };

  // Position player
  function resetPlayer() {
    state.player.w = Math.max(34, Math.min(56, Math.floor(Math.min(width,height) * 0.06)));
    state.player.h = state.player.w;
    state.player.x = (width - state.player.w) / 2;
    state.player.y = height - state.player.h - 22;
    state.player.vx = 0;
  }
  resetPlayer();

  // --- UI elements ---
  const scoreEl = document.getElementById("score");
  const bestEl  = document.getElementById("best");
  const startBtn= document.getElementById("startBtn");
  const pauseBtn= document.getElementById("pauseBtn");
  const overlay = document.getElementById("overlay");
  const leftPad = document.getElementById("leftPad");
  const rightPad= document.getElementById("rightPad");

  bestEl.textContent = state.best;

  // --- Input handling (touch / pointer / keyboard) ---
  // Prevent Safari double-tap zoom / scroll on controls
  const prevent = (e)=>{ e.preventDefault(); };

  ["touchstart","touchmove","touchend","gesturestart"].forEach(ev=>{
    document.addEventListener(ev, prevent, { passive:false });
  });

  // Pads
  function bindPad(el, dir) {
    let active = false;
    const onDown = (e)=>{ active = true; if (dir<0) state.input.left=true; else state.input.right=true; };
    const onUp   = (e)=>{ active = false; if (dir<0) state.input.left=false; else state.input.right=false; };
    el.addEventListener("pointerdown", onDown);
    el.addEventListener("pointerup", onUp);
    el.addEventListener("pointercancel", onUp);
    el.addEventListener("pointerleave", onUp);
  }
  bindPad(leftPad, -1);
  bindPad(rightPad, 1);

  // Swipe anywhere
  let swipeActive=false, swipeStartX=0;
  canvas.addEventListener("pointerdown", (e)=>{
    swipeActive = true; swipeStartX = e.clientX;
  });
  window.addEventListener("pointermove", (e)=>{
    if (!swipeActive) return;
    const dx = e.clientX - swipeStartX;
    state.input.swipeVX = dx * 3; // scaled to feel snappy
  });
  window.addEventListener("pointerup", ()=>{
    swipeActive=false; state.input.swipeVX = 0;
  });

  // Keyboard (for desktop testing)
  window.addEventListener("keydown", (e)=>{
    if (e.key === "ArrowLeft" || e.key === "a") state.input.left = true;
    if (e.key === "ArrowRight"|| e.key === "d") state.input.right= true;
    if (e.key === " " ) togglePause();
  });
  window.addEventListener("keyup", (e)=>{
    if (e.key === "ArrowLeft" || e.key === "a") state.input.left = false;
    if (e.key === "ArrowRight"|| e.key === "d") state.input.right= false;
  });

  // --- Buttons ---
  startBtn.addEventListener("click", startGame);
  pauseBtn.addEventListener("click", togglePause);

  function startGame() {
    state.blocks.length = 0;
    state.score = 0;
    state.time = 0;
    state.blockTimer = 0;
    state.difficulty = 1;
    state.over = false;
    state.paused = false;
    resetPlayer();
    overlay.style.display = "none";
    state.running = true;
    state.last = performance.now();
    requestAnimationFrame(loop);
  }

  function gameOver() {
    state.over = true;
    state.running = false;
    overlay.style.display = "flex";
    overlay.querySelector(".title").textContent = "Game Over";
    overlay.querySelector(".subtitle").innerHTML =
      `You scored <strong>${Math.floor(state.score)}</strong>. ` +
      (state.score > state.best ? `<span class="danger">New high score!</span>` : `Try again!`);
    state.best = Math.max(state.best, Math.floor(state.score));
    localStorage.setItem("dodger_best", String(state.best));
    bestEl.textContent = state.best;
    startBtn.textContent = "Play Again";
  }

  function togglePause() {
    if (!state.running || state.over) return;
    state.paused = !state.paused;
    pauseBtn.textContent = state.paused ? "Resume" : "Pause";
    if (!state.paused) {
      state.last = performance.now();
      requestAnimationFrame(loop);
    } else {
      // show a subtle overlay hint
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.fillRect(0,0,width,height);
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.font = "700 20px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("Paused", width/2, height*0.45);
      ctx.restore();
    }
  }

  // --- Helpers ---
  function rand(min,max){ return Math.random()*(max-min)+min; }

  function spawnBlock() {
    const size = rand(Math.max(22, width*0.03), Math.max(38, width*0.07));
    const x = rand(0, width - size);
    const speed = rand(140, 190) * state.difficulty; // pixels/sec
    state.blocks.push({ x, y: -size, w: size, h: size, vy: speed });
  }

  function update(dt) {
    state.time += dt;
    state.score += dt * 10;
    state.difficulty = 1 + Math.min(2.2, state.time / 24); // ramps up over ~24s
    scoreEl.textContent = Math.floor(state.score);

    // Player velocity from input
    const p = state.player;
    const baseSpeed = p.speed * state.difficulty * 0.95;
    let targetVX = 0;
    if (state.input.left)  targetVX -= baseSpeed;
    if (state.input.right) targetVX += baseSpeed;
    targetVX += state.input.swipeVX; // swipe adds temporary nudge
    // Smooth towards target velocity
    p.vx += (targetVX - p.vx) * Math.min(1, dt * 10);
    p.x += p.vx * dt;
    // Clamp
    if (p.x < 0) { p.x = 0; p.vx = Math.max(0, p.vx); }
    if (p.x + p.w > width) { p.x = width - p.w; p.vx = Math.min(0, p.vx); }

    // Spawn blocks
    state.blockTimer -= dt;
    const interval = Math.max(0.22, 0.9 - state.time * 0.03);
    if (state.blockTimer <= 0) {
      spawnBlock();
      if (state.time > 12 && Math.random() < 0.35) spawnBlock(); // occasional doubles
      state.blockTimer = interval;
    }

    // Move blocks & cull
    const blocks = state.blocks;
    for (let i=blocks.length-1; i>=0; i--) {
      const b = blocks[i];
      b.y += b.vy * dt;
      if (b.y - b.h > height + 8) { blocks.splice(i,1); continue; }

      // Collision (AABB)
      if (b.x < p.x + p.w && b.x + b.w > p.x && b.y < p.y + p.h && b.y + b.h > p.y) {
        gameOver();
        return;
      }
    }
  }

  function draw() {
    // Background gradient
    const g = ctx.createLinearGradient(0,0,0,height);
    g.addColorStop(0,"#0b1220");
    g.addColorStop(1,"#0c0f14");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,width,height);

    // Subtle grid
    ctx.globalAlpha = 0.08;
    ctx.strokeStyle = "#8ab4ff";
    ctx.lineWidth = 1;
    const grid = Math.max(20, Math.floor(Math.min(width, height) * 0.04));
    ctx.beginPath();
    for (let x= (width%grid); x<width; x+=grid) { ctx.moveTo(x,0); ctx.lineTo(x,height); }
    for (let y= (height%grid); y<height; y+=grid){ ctx.moveTo(0,y); ctx.lineTo(width,y); }
    ctx.stroke();
    ctx.globalAlpha = 1;

    // Player
    const p = state.player;
    ctx.fillStyle = "#58a6ff";
    roundRect(ctx, p.x, p.y, p.w, p.h, Math.min(10, p.w*0.25), true);

    // Tail effect
    ctx.globalAlpha = 0.15;
    ctx.fillStyle = "#58a6ff";
    roundRect(ctx, p.x + p.w*0.2, p.y + p.h*0.65, p.w*0.6, p.h*0.9, 8, true);
    ctx.globalAlpha = 1;

    // Blocks
    for (const b of state.blocks) {
      ctx.fillStyle = "#ff6b6b";
      roundRect(ctx, b.x, b.y, b.w, b.h, Math.min(10, b.w*0.25), true);
      // shine
      ctx.globalAlpha = 0.15;
      ctx.fillStyle = "#ffffff";
      roundRect(ctx, b.x+ b.w*0.1, b.y + b.h*0.08, b.w*0.8, b.h*0.18, 8, true);
      ctx.globalAlpha = 1;
    }
  }

  function roundRect(ctx, x, y, w, h, r, fill) {
    ctx.beginPath();
    const rr = Math.min(r, w/2, h/2);
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y,   x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x,   y+h, rr);
    ctx.arcTo(x,   y+h, x,   y,   rr);
    ctx.arcTo(x,   y,   x+w, y,   rr);
    ctx.closePath();
    if (fill) ctx.fill();
  }

  // --- Main loop ---
  function loop(now) {
    if (!state.running || state.paused || state.over) return;
    const dt = Math.min(0.033, (now - state.last) / 1000); // clamp big jumps
    state.last = now;

    update(dt);
    draw();

    requestAnimationFrame(loop);
  }

  // Start screen renders once (behind overlay)
  draw();

})();
</script>
</body>
</html>
